// DxcOptimizer.inc - Generated by hctgen.py
// DO NOT MODIFY!!!
// Changes to this code are made in gen_intrin_main.txt

namespace hlsl {
HRESULT SetupRegistryPassForHLSL() {
  try {
    PassRegistry &Registry = *PassRegistry::getPassRegistry();
initializeADCEPass(Registry);
initializeAddDiscriminatorsPass(Registry);
initializeAlignmentFromAssumptionsPass(Registry);
initializeAlwaysInlinerPass(Registry);
initializeBDCEPass(Registry);
initializeBarrierNoopPass(Registry);
initializeBasicAliasAnalysisPass(Registry);
initializeCFGSimplifyPassPass(Registry);
initializeCFLAliasAnalysisPass(Registry);
initializeCleanupDxBreakPass(Registry);
initializeComputeViewIdStatePass(Registry);
initializeConstantMergePass(Registry);
initializeCorrelatedValuePropagationPass(Registry);
initializeDAEPass(Registry);
initializeDAHPass(Registry);
initializeDCEPass(Registry);
initializeDSEPass(Registry);
initializeDeadInstEliminationPass(Registry);
initializeDxilAllocateResourcesForLibPass(Registry);
initializeDxilCleanupAddrSpaceCastPass(Registry);
initializeDxilCleanupDynamicResourceHandlePass(Registry);
initializeDxilConditionalMem2RegPass(Registry);
initializeDxilConvergentClearPass(Registry);
initializeDxilConvergentMarkPass(Registry);
initializeDxilDeadFunctionEliminationPass(Registry);
initializeDxilDeleteRedundantDebugValuesPass(Registry);
initializeDxilEliminateOutputDynamicIndexingPass(Registry);
initializeDxilEliminateVectorPass(Registry);
initializeDxilEmitMetadataPass(Registry);
initializeDxilEraseDeadRegionPass(Registry);
initializeDxilExpandTrigIntrinsicsPass(Registry);
initializeDxilFinalizeModulePass(Registry);
initializeDxilFinalizePreservesPass(Registry);
initializeDxilFixConstArrayInitializerPass(Registry);
initializeDxilGenerationPassPass(Registry);
initializeDxilInsertPreservesPass(Registry);
initializeDxilLegalizeEvalOperationsPass(Registry);
initializeDxilLegalizeResourcesPass(Registry);
initializeDxilLegalizeSampleOffsetPassPass(Registry);
initializeDxilLoadMetadataPass(Registry);
initializeDxilLoopDeletionPass(Registry);
initializeDxilLoopDeletionPass(Registry);
initializeDxilLoopUnrollPass(Registry);
initializeDxilLowerCreateHandleForLibPass(Registry);
initializeDxilMutateResourceToHandlePass(Registry);
initializeDxilNoOptLegalizePass(Registry);
initializeDxilNoOptSimplifyInstructionsPass(Registry);
initializeDxilPrecisePropagatePassPass(Registry);
initializeDxilPreserveAllOutputsPass(Registry);
initializeDxilPreserveToSelectPass(Registry);
initializeDxilPromoteLocalResourcesPass(Registry);
initializeDxilPromoteStaticResourcesPass(Registry);
initializeDxilReinsertNopsPass(Registry);
initializeDxilRemoveDeadBlocksPass(Registry);
initializeDxilRenameResourcesPass(Registry);
initializeDxilRewriteOutputArgDebugInfoPass(Registry);
initializeDxilSimpleGVNEliminateRegionPass(Registry);
initializeDxilSimpleGVNHoistPass(Registry);
initializeDxilTranslateRawBufferPass(Registry);
initializeDxilValidateWaveSensitivityPass(Registry);
initializeDxilValueCachePass(Registry);
initializeDynamicIndexingVectorToArrayPass(Registry);
initializeEarlyCSELegacyPassPass(Registry);
initializeEliminateAvailableExternallyPass(Registry);
initializeFloat2IntPass(Registry);
initializeFunctionAttrsPass(Registry);
initializeGVNPass(Registry);
initializeGlobalDCEPass(Registry);
initializeGlobalOptPass(Registry);
initializeHLDeadFunctionEliminationPass(Registry);
initializeHLEmitMetadataPass(Registry);
initializeHLEnsureMetadataPass(Registry);
initializeHLExpandStoreIntrinsicsPass(Registry);
initializeHLLegalizeParameterPass(Registry);
initializeHLMatrixLowerPassPass(Registry);
initializeHLPreprocessPass(Registry);
initializeHoistConstantArrayPass(Registry);
initializeIPSCCPPass(Registry);
initializeIndVarSimplifyPass(Registry);
initializeInstructionCombiningPassPass(Registry);
initializeInvalidateUndefResourcesPass(Registry);
initializeJumpThreadingPass(Registry);
initializeLICMPass(Registry);
initializeLoadCombinePass(Registry);
initializeLoopDeletionPass(Registry);
initializeLoopDistributePass(Registry);
initializeLoopIdiomRecognizePass(Registry);
initializeLoopInterchangePass(Registry);
initializeLoopRerollPass(Registry);
initializeLoopRotatePass(Registry);
initializeLoopUnrollPass(Registry);
initializeLoopUnswitchPass(Registry);
initializeLowerBitSetsPass(Registry);
initializeLowerExpectIntrinsicPass(Registry);
initializeLowerStaticGlobalIntoAllocaPass(Registry);
initializeMatrixBitcastLowerPassPass(Registry);
initializeMergeFunctionsPass(Registry);
initializeMergedLoadStoreMotionPass(Registry);
initializeMultiDimArrayToOneDimArrayPass(Registry);
initializeNoPausePassesPass(Registry);
initializePausePassesPass(Registry);
initializePromotePassPass(Registry);
initializePruneEHPass(Registry);
initializeReassociatePass(Registry);
initializeReducibilityAnalysisPass(Registry);
initializeRegToMemHlslPass(Registry);
initializeResourceToHandlePass(Registry);
initializeResumePassesPass(Registry);
initializeRewriteSymbolsPass(Registry);
initializeSCCPPass(Registry);
initializeSROAPass(Registry);
initializeSROA_DTPass(Registry);
initializeSROA_Parameter_HLSLPass(Registry);
initializeSROA_SSAUpPass(Registry);
initializeSampleProfileLoaderPass(Registry);
initializeScalarizerPass(Registry);
initializeScopedNoAliasAAPass(Registry);
initializeSimpleInlinerPass(Registry);
initializeSimplifyInstPass(Registry);
initializeStripDeadPrototypesPassPass(Registry);
initializeTargetLibraryInfoWrapperPassPass(Registry);
initializeTargetTransformInfoWrapperPassPass(Registry);
initializeTypeBasedAliasAnalysisPass(Registry);
initializeVerifierLegacyPassPass(Registry);
    // Not schematized - exclusively for compiler authors.
    initializeCFGPrinterPasses(Registry);
  }
  CATCH_CPP_RETURN_HRESULT();
  return S_OK;
}
} // namespace hlsl

static ArrayRef<LPCSTR> GetPassArgNames(LPCSTR passName) {static const LPCSTR AddDiscriminatorsArgs[] = { "no-discriminators" };
static const LPCSTR AlwaysInlinerArgs[] = { "InsertLifetime", "InlineThreshold" };
static const LPCSTR CFGSimplifyPassArgs[] = { "Threshold", "Ftor", "bonus-inst-threshold" };
static const LPCSTR DxilAddPixelHitInstrumentationArgs[] = { "force-early-z", "add-pixel-cost", "rt-width", "sv-position-index", "num-pixels" };
static const LPCSTR DxilAnnotateWithVirtualRegisterArgs[] = { "startInstruction" };
static const LPCSTR DxilConditionalMem2RegArgs[] = { "NoOpt" };
static const LPCSTR DxilDebugInstrumentationArgs[] = { "UAVSize", "FirstInstruction", "LastInstruction", "parameter0", "parameter1", "parameter2" };
static const LPCSTR DxilGenerationPassArgs[] = { "NotOptimized" };
static const LPCSTR DxilInsertPreservesArgs[] = { "AllowPreserves" };
static const LPCSTR DxilLoopDeletionArgs[] = { "NoSink" };
static const LPCSTR DxilLoopUnrollArgs[] = { "MaxIterationAttempt", "OnlyWarnOnFail" };
static const LPCSTR DxilOutputColorBecomesConstantArgs[] = { "mod-mode", "constant-red", "constant-green", "constant-blue", "constant-alpha" };
static const LPCSTR DxilPIXAddTidToAmplificationShaderPayloadArgs[] = { "dispatchArgY", "dispatchArgZ" };
static const LPCSTR DxilPIXDXRInvocationsLogArgs[] = { "maxNumEntriesInLog" };
static const LPCSTR DxilPIXMeshShaderOutputInstrumentationArgs[] = { "expand-payload", "UAVSize" };
static const LPCSTR DxilRenameResourcesArgs[] = { "prefix", "from-binding", "keep-name" };
static const LPCSTR DxilShaderAccessTrackingArgs[] = { "config", "checkForDynamicIndexing" };
static const LPCSTR DynamicIndexingVectorToArrayArgs[] = { "ReplaceAllVectors" };
static const LPCSTR Float2IntArgs[] = { "float2int-max-integer-bw" };
static const LPCSTR GVNArgs[] = { "noloads", "enable-pre", "enable-load-pre", "max-recurse-depth" };
static const LPCSTR InstructionCombiningPassArgs[] = { "NoSink" };
static const LPCSTR JumpThreadingArgs[] = { "Threshold", "jump-threading-threshold" };
static const LPCSTR LICMArgs[] = { "disable-licm-promotion" };
static const LPCSTR LoopDistributeArgs[] = { "loop-distribute-verify", "loop-distribute-non-if-convertible" };
static const LPCSTR LoopRerollArgs[] = { "max-reroll-increment", "reroll-num-tolerated-failed-matches" };
static const LPCSTR LoopRotateArgs[] = { "MaxHeaderSize", "rotation-max-header-size" };
static const LPCSTR LoopUnrollArgs[] = { "Threshold", "Count", "AllowPartial", "Runtime", "unroll-threshold", "unroll-percent-dynamic-cost-saved-threshold", "unroll-dynamic-cost-savings-discount", "unroll-max-iteration-count-to-analyze", "unroll-count", "unroll-allow-partial", "unroll-runtime", "pragma-unroll-threshold" };
static const LPCSTR LoopUnswitchArgs[] = { "Os", "loop-unswitch-threshold" };
static const LPCSTR LowerBitSetsArgs[] = { "lowerbitsets-avoid-reuse" };
static const LPCSTR LowerExpectIntrinsicArgs[] = { "likely-branch-weight", "unlikely-branch-weight" };
static const LPCSTR MergeFunctionsArgs[] = { "mergefunc-sanity" };
static const LPCSTR RewriteSymbolsArgs[] = { "DL", "rewrite-map-file" };
static const LPCSTR SROAArgs[] = { "RequiresDomTree", "SkipHLSLMat", "force-ssa-updater", "sroa-random-shuffle-slices", "sroa-strict-inbounds" };
static const LPCSTR SROA_DTArgs[] = { "Threshold", "StructMemberThreshold", "ArrayElementThreshold", "ScalarLoadThreshold" };
static const LPCSTR SROA_SSAUpArgs[] = { "Threshold", "StructMemberThreshold", "ArrayElementThreshold", "ScalarLoadThreshold" };
static const LPCSTR SampleProfileLoaderArgs[] = { "sample-profile-file", "sample-profile-max-propagate-iterations" };
static const LPCSTR ScopedNoAliasAAArgs[] = { "enable-scoped-noalias" };
static const LPCSTR SimpleInlinerArgs[] = { "InsertLifetime", "InlineThreshold" };
static const LPCSTR TargetLibraryInfoWrapperPassArgs[] = { "TLIImpl", "vector-library" };
static const LPCSTR TargetTransformInfoWrapperPassArgs[] = { "TIRA" };
static const LPCSTR TypeBasedAliasAnalysisArgs[] = { "enable-tbaa" };
static const LPCSTR VerifierLegacyPassArgs[] = { "FatalErrors", "verify-debug-info" };
if (strcmp(passName, "add-discriminators") == 0) return ArrayRef<LPCSTR>(AddDiscriminatorsArgs, _countof(AddDiscriminatorsArgs));
if (strcmp(passName, "always-inline") == 0) return ArrayRef<LPCSTR>(AlwaysInlinerArgs, _countof(AlwaysInlinerArgs));
if (strcmp(passName, "simplifycfg") == 0) return ArrayRef<LPCSTR>(CFGSimplifyPassArgs, _countof(CFGSimplifyPassArgs));
if (strcmp(passName, "hlsl-dxil-add-pixel-hit-instrmentation") == 0) return ArrayRef<LPCSTR>(DxilAddPixelHitInstrumentationArgs, _countof(DxilAddPixelHitInstrumentationArgs));
if (strcmp(passName, "dxil-annotate-with-virtual-regs") == 0) return ArrayRef<LPCSTR>(DxilAnnotateWithVirtualRegisterArgs, _countof(DxilAnnotateWithVirtualRegisterArgs));
if (strcmp(passName, "dxil-cond-mem2reg") == 0) return ArrayRef<LPCSTR>(DxilConditionalMem2RegArgs, _countof(DxilConditionalMem2RegArgs));
if (strcmp(passName, "hlsl-dxil-debug-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilDebugInstrumentationArgs, _countof(DxilDebugInstrumentationArgs));
if (strcmp(passName, "dxilgen") == 0) return ArrayRef<LPCSTR>(DxilGenerationPassArgs, _countof(DxilGenerationPassArgs));
if (strcmp(passName, "dxil-insert-preserves") == 0) return ArrayRef<LPCSTR>(DxilInsertPreservesArgs, _countof(DxilInsertPreservesArgs));
if (strcmp(passName, "dxil-loop-deletion") == 0) return ArrayRef<LPCSTR>(DxilLoopDeletionArgs, _countof(DxilLoopDeletionArgs));
if (strcmp(passName, "dxil-loop-unroll") == 0) return ArrayRef<LPCSTR>(DxilLoopUnrollArgs, _countof(DxilLoopUnrollArgs));
if (strcmp(passName, "hlsl-dxil-constantColor") == 0) return ArrayRef<LPCSTR>(DxilOutputColorBecomesConstantArgs, _countof(DxilOutputColorBecomesConstantArgs));
if (strcmp(passName, "hlsl-dxil-PIX-add-tid-to-as-payload") == 0) return ArrayRef<LPCSTR>(DxilPIXAddTidToAmplificationShaderPayloadArgs, _countof(DxilPIXAddTidToAmplificationShaderPayloadArgs));
if (strcmp(passName, "hlsl-dxil-pix-dxr-invocations-log") == 0) return ArrayRef<LPCSTR>(DxilPIXDXRInvocationsLogArgs, _countof(DxilPIXDXRInvocationsLogArgs));
if (strcmp(passName, "hlsl-dxil-pix-meshshader-output-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilPIXMeshShaderOutputInstrumentationArgs, _countof(DxilPIXMeshShaderOutputInstrumentationArgs));
if (strcmp(passName, "dxil-rename-resources") == 0) return ArrayRef<LPCSTR>(DxilRenameResourcesArgs, _countof(DxilRenameResourcesArgs));
if (strcmp(passName, "hlsl-dxil-pix-shader-access-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilShaderAccessTrackingArgs, _countof(DxilShaderAccessTrackingArgs));
if (strcmp(passName, "dynamic-vector-to-array") == 0) return ArrayRef<LPCSTR>(DynamicIndexingVectorToArrayArgs, _countof(DynamicIndexingVectorToArrayArgs));
if (strcmp(passName, "float2int") == 0) return ArrayRef<LPCSTR>(Float2IntArgs, _countof(Float2IntArgs));
if (strcmp(passName, "gvn") == 0) return ArrayRef<LPCSTR>(GVNArgs, _countof(GVNArgs));
if (strcmp(passName, "instcombine") == 0) return ArrayRef<LPCSTR>(InstructionCombiningPassArgs, _countof(InstructionCombiningPassArgs));
if (strcmp(passName, "jump-threading") == 0) return ArrayRef<LPCSTR>(JumpThreadingArgs, _countof(JumpThreadingArgs));
if (strcmp(passName, "licm") == 0) return ArrayRef<LPCSTR>(LICMArgs, _countof(LICMArgs));
if (strcmp(passName, "loop-distribute") == 0) return ArrayRef<LPCSTR>(LoopDistributeArgs, _countof(LoopDistributeArgs));
if (strcmp(passName, "loop-reroll") == 0) return ArrayRef<LPCSTR>(LoopRerollArgs, _countof(LoopRerollArgs));
if (strcmp(passName, "loop-rotate") == 0) return ArrayRef<LPCSTR>(LoopRotateArgs, _countof(LoopRotateArgs));
if (strcmp(passName, "loop-unroll") == 0) return ArrayRef<LPCSTR>(LoopUnrollArgs, _countof(LoopUnrollArgs));
if (strcmp(passName, "loop-unswitch") == 0) return ArrayRef<LPCSTR>(LoopUnswitchArgs, _countof(LoopUnswitchArgs));
if (strcmp(passName, "lowerbitsets") == 0) return ArrayRef<LPCSTR>(LowerBitSetsArgs, _countof(LowerBitSetsArgs));
if (strcmp(passName, "lower-expect") == 0) return ArrayRef<LPCSTR>(LowerExpectIntrinsicArgs, _countof(LowerExpectIntrinsicArgs));
if (strcmp(passName, "mergefunc") == 0) return ArrayRef<LPCSTR>(MergeFunctionsArgs, _countof(MergeFunctionsArgs));
if (strcmp(passName, "rewrite-symbols") == 0) return ArrayRef<LPCSTR>(RewriteSymbolsArgs, _countof(RewriteSymbolsArgs));
if (strcmp(passName, "sroa") == 0) return ArrayRef<LPCSTR>(SROAArgs, _countof(SROAArgs));
if (strcmp(passName, "scalarrepl") == 0) return ArrayRef<LPCSTR>(SROA_DTArgs, _countof(SROA_DTArgs));
if (strcmp(passName, "scalarrepl-ssa") == 0) return ArrayRef<LPCSTR>(SROA_SSAUpArgs, _countof(SROA_SSAUpArgs));
if (strcmp(passName, "sample-profile") == 0) return ArrayRef<LPCSTR>(SampleProfileLoaderArgs, _countof(SampleProfileLoaderArgs));
if (strcmp(passName, "scoped-noalias") == 0) return ArrayRef<LPCSTR>(ScopedNoAliasAAArgs, _countof(ScopedNoAliasAAArgs));
if (strcmp(passName, "inline") == 0) return ArrayRef<LPCSTR>(SimpleInlinerArgs, _countof(SimpleInlinerArgs));
if (strcmp(passName, "targetlibinfo") == 0) return ArrayRef<LPCSTR>(TargetLibraryInfoWrapperPassArgs, _countof(TargetLibraryInfoWrapperPassArgs));
if (strcmp(passName, "tti") == 0) return ArrayRef<LPCSTR>(TargetTransformInfoWrapperPassArgs, _countof(TargetTransformInfoWrapperPassArgs));
if (strcmp(passName, "tbaa") == 0) return ArrayRef<LPCSTR>(TypeBasedAliasAnalysisArgs, _countof(TypeBasedAliasAnalysisArgs));
if (strcmp(passName, "verify") == 0) return ArrayRef<LPCSTR>(VerifierLegacyPassArgs, _countof(VerifierLegacyPassArgs));

return ArrayRef<LPCSTR>();
}

static ArrayRef<LPCSTR> GetPassArgDescriptions(LPCSTR passName) {
static const LPCSTR AddDiscriminatorsArgs[] = { "None" };
static const LPCSTR AlwaysInlinerArgs[] = { "Insert @llvm.lifetime intrinsics", "Insert @llvm.lifetime intrinsics" };
static const LPCSTR CFGSimplifyPassArgs[] = { "None", "None", "Control the number of bonus instructions (default = 1)" };
static const LPCSTR DxilAddPixelHitInstrumentationArgs[] = { "None", "None", "None", "None", "None" };
static const LPCSTR DxilAnnotateWithVirtualRegisterArgs[] = { "None" };
static const LPCSTR DxilConditionalMem2RegArgs[] = { "None" };
static const LPCSTR DxilDebugInstrumentationArgs[] = { "None", "None", "None", "None", "None", "None" };
static const LPCSTR DxilGenerationPassArgs[] = { "None" };
static const LPCSTR DxilInsertPreservesArgs[] = { "None" };
static const LPCSTR DxilLoopDeletionArgs[] = { "None" };
static const LPCSTR DxilLoopUnrollArgs[] = { "Maximum number of iterations to attempt when iteratively unrolling.", "Whether to just warn when unrolling fails." };
static const LPCSTR DxilOutputColorBecomesConstantArgs[] = { "None", "None", "None", "None", "None" };
static const LPCSTR DxilPIXAddTidToAmplificationShaderPayloadArgs[] = { "None", "None" };
static const LPCSTR DxilPIXDXRInvocationsLogArgs[] = { "None" };
static const LPCSTR DxilPIXMeshShaderOutputInstrumentationArgs[] = { "None", "None" };
static const LPCSTR DxilRenameResourcesArgs[] = { "Prefix to add to resource names", "Append binding to name when bound", "Keep name when appending binding" };
static const LPCSTR DxilShaderAccessTrackingArgs[] = { "None", "None" };
static const LPCSTR DynamicIndexingVectorToArrayArgs[] = { "None" };
static const LPCSTR Float2IntArgs[] = { "Max integer bitwidth to consider in float2int" };
static const LPCSTR GVNArgs[] = { "None", "None", "None", "Max recurse depth" };
static const LPCSTR InstructionCombiningPassArgs[] = { "None" };
static const LPCSTR JumpThreadingArgs[] = { "None", "Max block size to duplicate for jump threading" };
static const LPCSTR LICMArgs[] = { "Disable memory promotion in LICM pass" };
static const LPCSTR LoopDistributeArgs[] = { "Turn on DominatorTree and LoopInfo verification after Loop Distribution", "Whether to distribute into a loop that may not be if-convertible by the loop vectorizer" };
static const LPCSTR LoopRerollArgs[] = { "The maximum increment for loop rerolling", "The maximum number of failures to tolerate during fuzzy matching." };
static const LPCSTR LoopRotateArgs[] = { "None", "The default maximum header size for automatic loop rotation" };
static const LPCSTR LoopUnrollArgs[] = { "None", "None", "None", "None", "The baseline cost threshold for loop unrolling", "The percentage of estimated dynamic cost which must be saved by unrolling to allow unrolling up to the max threshold.", "This is the amount discounted from the total unroll cost when the unrolled form has a high dynamic cost savings (triggered by the '-unroll-perecent-dynamic-cost-saved-threshold' flag).", "Don't allow loop unrolling to simulate more than this number of iterations when checking full unroll profitability", "Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes", "Allows loops to be partially unrolled until -unroll-threshold loop size is reached.", "Unroll loops with run-time trip counts", "Unrolled size limit for loops with an unroll(full) or unroll_count pragma." };
static const LPCSTR LoopUnswitchArgs[] = { "Optimize for size", "Max loop size to unswitch" };
static const LPCSTR LowerBitSetsArgs[] = { "Try to avoid reuse of byte array addresses using aliases" };
static const LPCSTR LowerExpectIntrinsicArgs[] = { "Weight of the branch likely to be taken (default = 64)", "Weight of the branch unlikely to be taken (default = 4)" };
static const LPCSTR MergeFunctionsArgs[] = { "How many functions in module could be used for MergeFunctions pass sanity check. '0' disables this check. Works only with '-debug' key." };
static const LPCSTR RewriteSymbolsArgs[] = { "None", "None" };
static const LPCSTR SROAArgs[] = { "None", "None", "Force the pass to not use DomTree and mem2reg, insteadforming SSA values through the SSAUpdater infrastructure.", "Enable randomly shuffling the slices to help uncover instability in their order.", "Experiment with completely strict handling of inbounds GEPs." };
static const LPCSTR SROA_DTArgs[] = { "None", "None", "None", "None" };
static const LPCSTR SROA_SSAUpArgs[] = { "None", "None", "None", "None" };
static const LPCSTR SampleProfileLoaderArgs[] = { "None", "None" };
static const LPCSTR ScopedNoAliasAAArgs[] = { "Use to disable scoped no-alias" };
static const LPCSTR SimpleInlinerArgs[] = { "Insert @llvm.lifetime intrinsics", "Insert @llvm.lifetime intrinsics" };
static const LPCSTR TargetLibraryInfoWrapperPassArgs[] = { "None", "None" };
static const LPCSTR TargetTransformInfoWrapperPassArgs[] = { "None" };
static const LPCSTR TypeBasedAliasAnalysisArgs[] = { "Use to disable TBAA functionality" };
static const LPCSTR VerifierLegacyPassArgs[] = { "None", "None" };
if (strcmp(passName, "add-discriminators") == 0) return ArrayRef<LPCSTR>(AddDiscriminatorsArgs, _countof(AddDiscriminatorsArgs));
if (strcmp(passName, "always-inline") == 0) return ArrayRef<LPCSTR>(AlwaysInlinerArgs, _countof(AlwaysInlinerArgs));
if (strcmp(passName, "simplifycfg") == 0) return ArrayRef<LPCSTR>(CFGSimplifyPassArgs, _countof(CFGSimplifyPassArgs));
if (strcmp(passName, "hlsl-dxil-add-pixel-hit-instrmentation") == 0) return ArrayRef<LPCSTR>(DxilAddPixelHitInstrumentationArgs, _countof(DxilAddPixelHitInstrumentationArgs));
if (strcmp(passName, "dxil-annotate-with-virtual-regs") == 0) return ArrayRef<LPCSTR>(DxilAnnotateWithVirtualRegisterArgs, _countof(DxilAnnotateWithVirtualRegisterArgs));
if (strcmp(passName, "dxil-cond-mem2reg") == 0) return ArrayRef<LPCSTR>(DxilConditionalMem2RegArgs, _countof(DxilConditionalMem2RegArgs));
if (strcmp(passName, "hlsl-dxil-debug-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilDebugInstrumentationArgs, _countof(DxilDebugInstrumentationArgs));
if (strcmp(passName, "dxilgen") == 0) return ArrayRef<LPCSTR>(DxilGenerationPassArgs, _countof(DxilGenerationPassArgs));
if (strcmp(passName, "dxil-insert-preserves") == 0) return ArrayRef<LPCSTR>(DxilInsertPreservesArgs, _countof(DxilInsertPreservesArgs));
if (strcmp(passName, "dxil-loop-deletion") == 0) return ArrayRef<LPCSTR>(DxilLoopDeletionArgs, _countof(DxilLoopDeletionArgs));
if (strcmp(passName, "dxil-loop-unroll") == 0) return ArrayRef<LPCSTR>(DxilLoopUnrollArgs, _countof(DxilLoopUnrollArgs));
if (strcmp(passName, "hlsl-dxil-constantColor") == 0) return ArrayRef<LPCSTR>(DxilOutputColorBecomesConstantArgs, _countof(DxilOutputColorBecomesConstantArgs));
if (strcmp(passName, "hlsl-dxil-PIX-add-tid-to-as-payload") == 0) return ArrayRef<LPCSTR>(DxilPIXAddTidToAmplificationShaderPayloadArgs, _countof(DxilPIXAddTidToAmplificationShaderPayloadArgs));
if (strcmp(passName, "hlsl-dxil-pix-dxr-invocations-log") == 0) return ArrayRef<LPCSTR>(DxilPIXDXRInvocationsLogArgs, _countof(DxilPIXDXRInvocationsLogArgs));
if (strcmp(passName, "hlsl-dxil-pix-meshshader-output-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilPIXMeshShaderOutputInstrumentationArgs, _countof(DxilPIXMeshShaderOutputInstrumentationArgs));
if (strcmp(passName, "dxil-rename-resources") == 0) return ArrayRef<LPCSTR>(DxilRenameResourcesArgs, _countof(DxilRenameResourcesArgs));
if (strcmp(passName, "hlsl-dxil-pix-shader-access-instrumentation") == 0) return ArrayRef<LPCSTR>(DxilShaderAccessTrackingArgs, _countof(DxilShaderAccessTrackingArgs));
if (strcmp(passName, "dynamic-vector-to-array") == 0) return ArrayRef<LPCSTR>(DynamicIndexingVectorToArrayArgs, _countof(DynamicIndexingVectorToArrayArgs));
if (strcmp(passName, "float2int") == 0) return ArrayRef<LPCSTR>(Float2IntArgs, _countof(Float2IntArgs));
if (strcmp(passName, "gvn") == 0) return ArrayRef<LPCSTR>(GVNArgs, _countof(GVNArgs));
if (strcmp(passName, "instcombine") == 0) return ArrayRef<LPCSTR>(InstructionCombiningPassArgs, _countof(InstructionCombiningPassArgs));
if (strcmp(passName, "jump-threading") == 0) return ArrayRef<LPCSTR>(JumpThreadingArgs, _countof(JumpThreadingArgs));
if (strcmp(passName, "licm") == 0) return ArrayRef<LPCSTR>(LICMArgs, _countof(LICMArgs));
if (strcmp(passName, "loop-distribute") == 0) return ArrayRef<LPCSTR>(LoopDistributeArgs, _countof(LoopDistributeArgs));
if (strcmp(passName, "loop-reroll") == 0) return ArrayRef<LPCSTR>(LoopRerollArgs, _countof(LoopRerollArgs));
if (strcmp(passName, "loop-rotate") == 0) return ArrayRef<LPCSTR>(LoopRotateArgs, _countof(LoopRotateArgs));
if (strcmp(passName, "loop-unroll") == 0) return ArrayRef<LPCSTR>(LoopUnrollArgs, _countof(LoopUnrollArgs));
if (strcmp(passName, "loop-unswitch") == 0) return ArrayRef<LPCSTR>(LoopUnswitchArgs, _countof(LoopUnswitchArgs));
if (strcmp(passName, "lowerbitsets") == 0) return ArrayRef<LPCSTR>(LowerBitSetsArgs, _countof(LowerBitSetsArgs));
if (strcmp(passName, "lower-expect") == 0) return ArrayRef<LPCSTR>(LowerExpectIntrinsicArgs, _countof(LowerExpectIntrinsicArgs));
if (strcmp(passName, "mergefunc") == 0) return ArrayRef<LPCSTR>(MergeFunctionsArgs, _countof(MergeFunctionsArgs));
if (strcmp(passName, "rewrite-symbols") == 0) return ArrayRef<LPCSTR>(RewriteSymbolsArgs, _countof(RewriteSymbolsArgs));
if (strcmp(passName, "sroa") == 0) return ArrayRef<LPCSTR>(SROAArgs, _countof(SROAArgs));
if (strcmp(passName, "scalarrepl") == 0) return ArrayRef<LPCSTR>(SROA_DTArgs, _countof(SROA_DTArgs));
if (strcmp(passName, "scalarrepl-ssa") == 0) return ArrayRef<LPCSTR>(SROA_SSAUpArgs, _countof(SROA_SSAUpArgs));
if (strcmp(passName, "sample-profile") == 0) return ArrayRef<LPCSTR>(SampleProfileLoaderArgs, _countof(SampleProfileLoaderArgs));
if (strcmp(passName, "scoped-noalias") == 0) return ArrayRef<LPCSTR>(ScopedNoAliasAAArgs, _countof(ScopedNoAliasAAArgs));
if (strcmp(passName, "inline") == 0) return ArrayRef<LPCSTR>(SimpleInlinerArgs, _countof(SimpleInlinerArgs));
if (strcmp(passName, "targetlibinfo") == 0) return ArrayRef<LPCSTR>(TargetLibraryInfoWrapperPassArgs, _countof(TargetLibraryInfoWrapperPassArgs));
if (strcmp(passName, "tti") == 0) return ArrayRef<LPCSTR>(TargetTransformInfoWrapperPassArgs, _countof(TargetTransformInfoWrapperPassArgs));
if (strcmp(passName, "tbaa") == 0) return ArrayRef<LPCSTR>(TypeBasedAliasAnalysisArgs, _countof(TypeBasedAliasAnalysisArgs));
if (strcmp(passName, "verify") == 0) return ArrayRef<LPCSTR>(VerifierLegacyPassArgs, _countof(VerifierLegacyPassArgs));

return ArrayRef<LPCSTR>();
}

static bool IsPassOptionName(StringRef S) {
return S.equals("AllowPartial")
  ||  S.equals("AllowPreserves")
  ||  S.equals("ArrayElementThreshold")
  ||  S.equals("Count")
  ||  S.equals("DL")
  ||  S.equals("FatalErrors")
  ||  S.equals("FirstInstruction")
  ||  S.equals("Ftor")
  ||  S.equals("InlineThreshold")
  ||  S.equals("InsertLifetime")
  ||  S.equals("LastInstruction")
  ||  S.equals("MaxHeaderSize")
  ||  S.equals("MaxIterationAttempt")
  ||  S.equals("NoOpt")
  ||  S.equals("NoSink")
  ||  S.equals("NotOptimized")
  ||  S.equals("OnlyWarnOnFail")
  ||  S.equals("Os")
  ||  S.equals("ReplaceAllVectors")
  ||  S.equals("RequiresDomTree")
  ||  S.equals("Runtime")
  ||  S.equals("ScalarLoadThreshold")
  ||  S.equals("SkipHLSLMat")
  ||  S.equals("StructMemberThreshold")
  ||  S.equals("TIRA")
  ||  S.equals("TLIImpl")
  ||  S.equals("Threshold")
  ||  S.equals("UAVSize")
  ||  S.equals("add-pixel-cost")
  ||  S.equals("bonus-inst-threshold")
  ||  S.equals("checkForDynamicIndexing")
  ||  S.equals("config")
  ||  S.equals("constant-alpha")
  ||  S.equals("constant-blue")
  ||  S.equals("constant-green")
  ||  S.equals("constant-red")
  ||  S.equals("disable-licm-promotion")
  ||  S.equals("dispatchArgY")
  ||  S.equals("dispatchArgZ")
  ||  S.equals("enable-load-pre")
  ||  S.equals("enable-pre")
  ||  S.equals("enable-scoped-noalias")
  ||  S.equals("enable-tbaa")
  ||  S.equals("expand-payload")
  ||  S.equals("float2int-max-integer-bw")
  ||  S.equals("force-early-z")
  ||  S.equals("force-ssa-updater")
  ||  S.equals("from-binding")
  ||  S.equals("jump-threading-threshold")
  ||  S.equals("keep-name")
  ||  S.equals("likely-branch-weight")
  ||  S.equals("loop-distribute-non-if-convertible")
  ||  S.equals("loop-distribute-verify")
  ||  S.equals("loop-unswitch-threshold")
  ||  S.equals("lowerbitsets-avoid-reuse")
  ||  S.equals("max-recurse-depth")
  ||  S.equals("max-reroll-increment")
  ||  S.equals("maxNumEntriesInLog")
  ||  S.equals("mergefunc-sanity")
  ||  S.equals("mod-mode")
  ||  S.equals("no-discriminators")
  ||  S.equals("noloads")
  ||  S.equals("num-pixels")
  ||  S.equals("parameter0")
  ||  S.equals("parameter1")
  ||  S.equals("parameter2")
  ||  S.equals("pragma-unroll-threshold")
  ||  S.equals("prefix")
  ||  S.equals("reroll-num-tolerated-failed-matches")
  ||  S.equals("rewrite-map-file")
  ||  S.equals("rotation-max-header-size")
  ||  S.equals("rt-width")
  ||  S.equals("sample-profile-file")
  ||  S.equals("sample-profile-max-propagate-iterations")
  ||  S.equals("sroa-random-shuffle-slices")
  ||  S.equals("sroa-strict-inbounds")
  ||  S.equals("startInstruction")
  ||  S.equals("sv-position-index")
  ||  S.equals("unlikely-branch-weight")
  ||  S.equals("unroll-allow-partial")
  ||  S.equals("unroll-count")
  ||  S.equals("unroll-dynamic-cost-savings-discount")
  ||  S.equals("unroll-max-iteration-count-to-analyze")
  ||  S.equals("unroll-percent-dynamic-cost-saved-threshold")
  ||  S.equals("unroll-runtime")
  ||  S.equals("unroll-threshold")
  ||  S.equals("vector-library")
  ||  S.equals("verify-debug-info");}
